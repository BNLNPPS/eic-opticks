#pragma once
/**
U4Random
==============

Controlling the random sequence returned by G4UniformRand using 
precooked array of randoms generated by curand 
(based on extracts from cfg4/CAlignEngine.cc)

Primary control *U4Random::setSequenceIndex* 
to set the photon_id sequence of randoms to consume from  
and then use *G4UniformRand* as normal which will internally use the 
below *U4Random::flat* method while this is enabled.

The idea is to control the random stream separately for each photon slot. 

This was developed from examples/Geant4/CerenkovStandalone/OpticksRandom.hh

**/

#include <vector>
#include "plog/Severity.h"
#include "CLHEP/Random/RandomEngine.h"
#include "U4_API_EXPORT.hh"
struct NP ; 

struct U4_API U4Random : public CLHEP::HepRandomEngine
{
    friend struct U4RandomTest ; 
    static const plog::Severity LEVEL ; 

    //static constexpr const char* DEFAULT_SEQPATH = "$PrecookedDir/QSimTest/rng_sequence/rng_sequence_f_ni1000000_nj16_nk16_tranche100000" ;  
    static constexpr const char* DEFAULT_SEQPATH = "$PrecookedDir/QSimTest/rng_sequence/rng_sequence_f_ni1000000_nj16_nk16_tranche100000/rng_sequence_f_ni100000_nj16_nk16_ioffset000000.npy" ; 

    static constexpr const char* OPTICKS_RANDOM_SEQPATH = "OPTICKS_RANDOM_SEQPATH" ; 
    static const char* SeqPath(); 

    static constexpr const char* NOTES = R"LITERAL(
U4Random::init : NOT READY ERROR
=================================

Instanciation of U4Random failed to load precooked randoms
either from a single .npy or a directory of multiple .npy 
for concatenation on loading. 

Steps to fix:

1. Check the value of envvar OPTICKS_RANDOM_SEQPATH points to precooked 
   randoms : either a single .npy or a directory containing one or more .npy

2. Generate the precooked randoms with::

   cd ~/opticks/qudarap/tests 
   ./rng_sequence.sh run 

3. run with envvars set to increase logging OR take actions on unclassified or selected stacks::

   export U4Random=INFO
   export U4Random_select_action=interrupt


)LITERAL";


    static const char* NAME ; 
    static U4Random* INSTANCE ; 
    static U4Random* Get(); 

    static void      SetSequenceIndex(int index); 
    static int       GetSequenceIndex(); 

    const char*              m_seqpath ; 
    const NP*                m_seq;  
    const float*             m_seq_values ; 
    int                      m_seq_ni ; 
    int                      m_seq_nv ; 

    int                      m_seq_index ; 

    NP*                      m_cur ; 
    int*                     m_cur_values ; 
    bool                     m_recycle ; 

    CLHEP::HepRandomEngine*  m_default ;


    const NP*                m_seqmask ; 
    int                      m_seqmask_ni ; 
    const size_t*            m_seqmask_values ; 
 
    //bool                     m_flat_debug ;   THIS HAS BECOME ESSENTIAL TO ALIGNMENT 
    double                   m_flat_prior ; 
    bool                     m_ready ; 
    std::vector<int>*        m_select ; 
    unsigned                 m_select_action ; 


    bool isSelect(int photon_idx, int flat_cursor) const ; 
    std::string descSelect(int photon_idx, int flat_cursor ) const; 

    static void SetSeed(long seed) ;  // non-zero seed required 


    U4Random(const char* seq_path=nullptr, const char* seqmask_path=nullptr); 
    void init() ; 
    bool isReady() const ; 
    std::string desc() const ; 
    std::string detail() const ; 

    virtual ~U4Random(); 

    size_t getNumIndices() const ;
    size_t getMaskedIndex(int index_);
    void setSequenceIndex(int index_);  
    int  getSequenceIndex() const ;

    double getFlatPrior() const ; 
    //unsigned getFlatTag() ; 


    // mandatory CLHEP::HepRandomEngine methods
    double flat();
    void flatArray(const int size, double* vect);
    void setSeed(long seed, int);
    void setSeeds(const long * seeds, int); 
    void saveStatus( const char filename[] = "Config.conf") const ;
    void restoreStatus( const char filename[] = "Config.conf" ) ;
    void showStatus() const ;
    std::string name() const ;

    void dump(unsigned n=10); 
    // internals
    private:
        void enable(); 
        void disable(); 


}; 

