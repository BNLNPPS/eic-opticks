/*
 * Copyright (c) 2019 Opticks Team. All Rights Reserved.
 *
 * This file is part of Opticks
 * (see https://bitbucket.org/simoncblyth/opticks).
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License.  
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
 * See the License for the specific language governing permissions and 
 * limitations under the License.
 */


#include <iterator>
#include <algorithm>

#include "Opticks.hh"

#include "G4Hype.hh"
#include "G4Polycone.hh"
#include "G4Ellipsoid.hh"
#include "G4Torus.hh"
#include "G4Cons.hh"
#include "G4Trd.hh"
#include "G4Tubs.hh"
#include "G4Box.hh"
#include "G4Orb.hh"
#include "G4MultiUnion.hh"
#include "G4Sphere.hh"
#include "G4BooleanSolid.hh"
#include "G4IntersectionSolid.hh"
#include "G4SubtractionSolid.hh"
#include "G4UnionSolid.hh"
#include "G4SystemOfUnits.hh"

#include "X4Transform3D.hh"
#include "X4AffineTransform.hh"
#include "X4Solid.hh"
#include "X4.hh"

#include "SId.hh"
#include "SSys.hh"
#include "BStr.hh"
#include "OpticksCSG.h"
#include "GLMFormat.hpp"
#include "NGLMExt.hpp"
#include "nmat4triple.hpp"
#include "NGLM.hpp"
#include "NHyperboloid.hpp"
#include "NTorus.hpp"
#include "NCone.hpp"
#include "NConvexPolyhedron.hpp"
#include "NCylinder.hpp"
#include "NZSphere.hpp"
#include "NSphere.hpp"
#include "NBox.hpp"
#include "NDisc.hpp"
#include "NMultiUnion.hpp"
#include "NPhiCut.hpp"
#include "NThetaCut.hpp"

#include "NNode.hpp"
#include "NTreeBuilder.hpp"
#include "NTreeProcess.hpp"

#include "SLOG.hh"

const plog::Severity X4Solid::LEVEL = SLOG::EnvLevel("X4Solid", "DEBUG") ;

unsigned X4Solid::fVerbosity = 0 ; 
void X4Solid::SetVerbosity(unsigned verbosity) // static
{
    fVerbosity = verbosity ; 
}


void X4Solid::Banner( int lvIdx, int soIdx, const char* lvname, const char* soname ) // static 
{
    LOG(LEVEL)
         << " lvIdx " << std::setw(5) << lvIdx 
         << " soIdx " << std::setw(5) << soIdx 
         << " soname " << soname
         << " lvname " << lvname
         ;
}



/**
X4Solid::Convert
-----------------

Canonicaly used from X4PhysicalVolume::convertSolid

Doing prepTree here triggers assert regarding not expected to change parent links
with geocache-tds.

**/

nnode* X4Solid::Convert(const G4VSolid* solid, const Opticks* ok, const char* boundary, int lvIdx )
{
    LOG(LEVEL) << "[ convert " << solid->GetName() << " lvIdx " << lvIdx ; 

    bool top = true ; 
    X4Solid xs(solid, ok, top, lvIdx );
    nnode* root = xs.getRoot(); 

    root->update_gtransforms(); 
    //root->prepTree(); // updates_gtransforms and sets parent links  


    if(boundary) root->boundary = boundary ; 


    bool hint_external_bbox = xs.hasHint() && xs.getHintCode() == CSG_EXBB ; 
    bool expect_external_bbox = CSG::ExpectExternalBBox(root->type)  ; 
    bool set_external_bbox = hint_external_bbox || expect_external_bbox ; 


    LOG(LEVEL) 
        << " hint_external_bbox  " << hint_external_bbox 
        << " expect_external_bbox " << expect_external_bbox 
        << " set_external_bbox  " << set_external_bbox 
        ; 

    if(set_external_bbox) 
    {
        SetExternalBoundingBox(root, solid); 
    }

    LOG(LEVEL) << "]" ;  

    return root ; 
}

/**
X4Solid::Balance
-----------------

Used from X4CSG::X4CSG during g4codegen

**/

nnode* X4Solid::Balance(nnode* raw, int soIdx, int lvIdx )
{
    nnode* root = NTreeProcess<nnode>::Process(raw, soIdx, lvIdx);  // balances deep trees, or if not deep retuns raw
    root->other = raw ; 
    root->boundary = raw->boundary ? strdup(raw->boundary) : NULL ; 
    // note that g4code is not passed, as its inconsistent with the balanced tree presumably 
    return root ; 
}


X4Solid::X4Solid(const G4VSolid* solid, const Opticks* ok, bool top, int lvIdx )
    :
    X4SolidBase(solid, ok, top, lvIdx),
    m_displaced(NULL)
{
    init(); 
}

X4Solid* X4Solid::getDisplaced() const
{
    return m_displaced ; 
}
bool X4Solid::hasDisplaced() const 
{
    return m_displaced != NULL ; 
}
void X4Solid::setDisplaced(X4Solid* displaced)
{
    m_displaced = displaced ; 
}


void X4Solid::init()
{
    LOG(LEVEL) << "[ "<< desc()  ; 
    switch( m_entityType )
    {
    // generated by x4-case- Tue Jun 19 22:28:05 HKT 2018 
    case _G4DisplacedSolid    : convertDisplacedSolid()        ; break ; 
    case _G4UnionSolid        : convertUnionSolid()            ; break ; 
    case _G4IntersectionSolid : convertIntersectionSolid()     ; break ; 
    case _G4SubtractionSolid  : convertSubtractionSolid()      ; break ; 
    case _G4MultiUnion        : convertMultiUnion()            ; break ; 
    case _G4Box               : convertBox()                   ; break ; 
    case _G4Cons              : convertCons()                  ; break ; 
    case _G4EllipticalCone    : convertEllipticalCone()        ; break ; 
    case _G4Ellipsoid         : convertEllipsoid()             ; break ; 
    case _G4EllipticalTube    : convertEllipticalTube()        ; break ; 
    case _G4ExtrudedSolid     : convertExtrudedSolid()         ; break ; 
    case _G4Hype              : convertHype()                  ; break ; 
    case _G4Orb               : convertOrb()                   ; break ; 
    case _G4Para              : convertPara()                  ; break ; 
    case _G4Paraboloid        : convertParaboloid()            ; break ; 
    case _G4Polycone          : convertPolycone()              ; break ; 
    case _G4GenericPolycone   : convertGenericPolycone()       ; break ; 
    case _G4Polyhedra         : convertPolyhedra()             ; break ; 
    case _G4Sphere            : convertSphere()                ; break ; 
    case _G4TessellatedSolid  : convertTessellatedSolid()      ; break ; 
    case _G4Tet               : convertTet()                   ; break ; 
    case _G4Torus             : convertTorus()                 ; break ; 
    case _G4GenericTrap       : convertGenericTrap()           ; break ; 
    case _G4Trap              : convertTrap()                  ; break ; 
    case _G4Trd               : convertTrd()                   ; break ; 
    case _G4Tubs              : convertTubs()                  ; break ; 
    case _G4CutTubs           : convertCutTubs()               ; break ; 
    case _G4TwistedBox        : convertTwistedBox()            ; break ; 
    case _G4TwistedTrap       : convertTwistedTrap()           ; break ; 
    case _G4TwistedTrd        : convertTwistedTrd()            ; break ; 
    case _G4TwistedTubs       : convertTwistedTubs()           ; break ; 
    } 
    LOG(LEVEL) << "]" ; 
}


G4ThreeVector X4Solid::GetAngles(const G4RotationMatrix& mtx)
{
   // from G4GDMLWriteDefine::GetAngles

    G4double x,y,z;
    G4RotationMatrix mat = mtx;
    mat.rectify();   // Rectify matrix from possible roundoff errors

    // Direction of rotation given by left-hand rule; clockwise rotation

    static const G4double kMatrixPrecision = 10E-10;
    const G4double cosb = std::sqrt(mtx.xx()*mtx.xx()+mtx.yx()*mtx.yx());

    if (cosb > kMatrixPrecision)
    {   
        x = std::atan2(mtx.zy(),mtx.zz());
        y = std::atan2(-mtx.zx(),cosb);
        z = std::atan2(mtx.yx(),mtx.xx());
    }   
    else
    {   
        x = std::atan2(-mtx.yz(),mtx.yy());
        y = std::atan2(-mtx.zx(),cosb);
        z = 0.0;
    }   

    return G4ThreeVector(x,y,z);
}

void X4Solid::booleanDisplacement( G4VSolid** pp, G4ThreeVector& pos, G4ThreeVector& rot )
{
    // cf /usr/local/opticks/externals/g4/geant4_10_02_p01/source/persistency/gdml/src/G4GDMLWriteSolids.cc
    int displaced = 0 ; 
    while (true)
    {  
      assert( displaced <= 8 );
      if (G4DisplacedSolid* disp = dynamic_cast<G4DisplacedSolid*>(*pp))
      {  
         pos += disp->GetObjectTranslation();
         rot += GetAngles(disp->GetObjectRotation());
         *pp = disp->GetConstituentMovedSolid();
         displaced++;
         continue;
      }
      break;
   }

   LOG(info) << " booleanDisplacement "
             << " pos " << pos 
             << " rot " << rot 
             ;
}

/**
X4Solid::convertUnionSolid
---------------------------

Solids with CSG_CONTIGUOUS hinting are converted via alternative approach 

**/

void X4Solid::convertUnionSolid()
{
    convertBooleanSolid() ;

    bool has_hint = hasHint() ; 
    LOG(LEVEL) << " has_hint " << has_hint << " desc " << desc() ; 

    if(has_hint) 
    {
        unsigned hint = getHintCode() ; 
        LOG(LEVEL) << " acting in hint " << CSG::Name(hint) << " within m_name " << m_name ; 
        changeToListSolid(hint) ;
    }
}
void X4Solid::convertIntersectionSolid()
{
    convertBooleanSolid() ;
}
void X4Solid::convertSubtractionSolid()
{
    convertBooleanSolid() ;
}

/**
X4Solid::convertDisplacedSolid
-------------------------------

The constituents of BooleanSolid which have displacements 
are represented by a G4DisplacedSolid

Note fixed for translation issue notes/issues/ellipsoid_not_maintaining_shape_within_boolean_combination.rst
was addressed by combining the prior scale transform with the displaced transform from 
the boolean combination. Although it seems to work the testing has not yet used rotation
so there could be transform combination glitches with other transforms.
 
**/

void X4Solid::convertDisplacedSolid()
{
    const G4DisplacedSolid* const disp = static_cast<const G4DisplacedSolid*>(m_solid);
    G4VSolid* moved = disp->GetConstituentMovedSolid() ;
    assert( dynamic_cast<G4DisplacedSolid*>(moved) == NULL ); // only a single displacement is handled

    bool top = false ;  // never top of tree : expect to always be a boolean RHS
    X4Solid* xmoved = new X4Solid(moved, m_ok, top);
    setDisplaced(xmoved); 

    nnode* a = xmoved->getRoot();

    LOG(LEVEL)
        << " a.csgname " << a->csgname()
        << " a.transform " << a->transform
        ;

    glm::mat4 xf_disp = X4Transform3D::GetDisplacementTransform(disp);  

    bool update_global = false ;   // update happens later,  after tree completed
    a->set_transform( xf_disp, update_global );   

    setRoot(a); 
}


void X4Solid::DumpTransform( const char* msg, const nmat4triple* transform ) // static 
{
    LOG(LEVEL)
        << msg 
        << std::endl  
        << gpresent("t", transform->t ) 
        << std::endl  
        << gpresent("v", transform->v )  
        << std::endl  
        << gpresent("q", transform->q ) 
        << std::endl  
        ;
}

/**
X4Solid::convertMultiUnion
---------------------------

**/

void X4Solid::convertMultiUnion()
{
    const G4MultiUnion* const compound = static_cast<const G4MultiUnion*>(m_solid);
    assert(compound); 

    //OpticksCSG_t type = CSG_DISCONTIGUOUS ;   
    OpticksCSG_t type = CSG_CONTIGUOUS ;   
    // TODO: set type depending on solid name 

    unsigned sub_num = compound->GetNumberOfSolids() ; 
    nnode* n_comp = nmultiunion::Create(type, sub_num) ;  

    int lvIdx = get_lvIdx();  // pass lvIdx to children 
    bool top = false ; 

    for( unsigned isub=0 ; isub < sub_num ; isub++)
    {
        const G4VSolid* sub = compound->GetSolid(isub);
        // TODO: assert that the constituents are primitives, not booleans or G4MultiUnion 
 
        const G4Transform3D& tr = compound->GetTransformation(isub) ;
        glm::mat4 tr_sub = X4Transform3D::Convert(tr); 

        X4Solid* x_sub = new X4Solid(sub, m_ok, top, lvIdx); 
        nnode* n_sub = x_sub->getRoot(); 

        bool update_global = true ;  
        n_sub->set_transform( tr_sub, update_global );  

        n_comp->subs.push_back(n_sub);      
    }

    setRoot(n_comp); 
}


/**
X4Solid::changeToListSolid
---------------------------------

Hmm need to collect all leaves of the subtree rooted here into a
compound like the above multiunion  

Need to apply the X4Solid conversion to the leaves only
and just collect flattened transforms from the operator nodes above them  

Hmm probably simplest to apply the normal convertBooleanSolid and 
then replace the nnode subtree. Because thats using the nnode 
lingo should do thing within nmultiunion

Just need to collect the list of nodes. Hmm maybe flatten transforms ?


Q: what about a list node within an ordinary CSG tree ?
A: see X4Solid::convertBooleanSolid the getRoot is called on the X4Solid from the 
   xleft and xright X4Solid instances and these are put together in an ordinary operator
   nnode. So what will happen is that the left or right of the operator node will 
   end up being set get set to the nmultiunion.

   To follow what happens next in the GeoChain need to see NCSG and how it handles
   the export on encountering the nmultiunion. 

**/

void X4Solid::changeToListSolid(unsigned hint)
{
    LOG(LEVEL) << "[ hint " << CSG::Name(hint)  ; 
    assert( hint == CSG_CONTIGUOUS || hint == CSG_DISCONTIGUOUS );  //  CSG_OVERLAP not implemented yet

    nnode* subtree = getRoot(); 
    OpticksCSG_t typecode = (OpticksCSG_t)hint ; 

    nmultiunion* root = nmultiunion::CreateFromTree(typecode, subtree) ; 
    setRoot(root); 
    LOG(LEVEL) << "]" ; 
}


/**
X4Solid::convertBooleanSolid
------------------------------

The transform which may be associated with the right child gets
captured by X4Solid::convertDisplacedSolid when the right child 
is a G4DisplacedSolid. 

**/


void X4Solid::convertBooleanSolid()
{  
    const G4BooleanSolid* const solid = static_cast<const G4BooleanSolid*>(m_solid);
    assert(solid); 

    OpticksCSG_t _operator = GetOperator(solid); 
    G4VSolid* left  = const_cast<G4VSolid*>(solid->GetConstituentSolid(0));
    G4VSolid* right = const_cast<G4VSolid*>(solid->GetConstituentSolid(1));

    bool is_left_displaced = dynamic_cast<G4DisplacedSolid*>(left) != NULL ;
    bool is_right_displaced = dynamic_cast<G4DisplacedSolid*>(right) != NULL ;

    assert( !is_left_displaced && "not expecting left displacement " ); 

    int lvIdx = get_lvIdx();  // pass lvIdx to children 
    bool top = false ; 
    X4Solid* xleft = new X4Solid(left, m_ok, top, lvIdx); 
    X4Solid* xright = new X4Solid(right, m_ok, top, lvIdx ); 

    nnode* a = xleft->getRoot(); 
    nnode* b = xright->getRoot(); 
    nnode* n = nnode::make_operator( _operator, a, b ); 

    setRoot(n); 


    /*
     Hmm will just detecting transforms on b catch em all ?
    
     Need to prepend the transform setup g4code to the node that 
     uses it and assign an transform identifiers for rotation and translation and
     refer to them in the below param list. 

     Hmm the AffineTransform ctor with all the numbers is private, so might as well use boolean 
     ctor with rotation and translation args ?

     X4RotationMatrix makes the protected ctor accessible but then are 
     not generating pure G4 code ? 
    */

    std::vector<std::string> param ;
    std::vector<std::string> keys ;
    param.push_back( xleft->getIdentifier() ); 
    keys.push_back( "left_id" );  

    if(is_right_displaced)
    {
        X4Solid* xright_displaced = xright->getDisplaced() ; 

        //assert(b->gtransform) ; 
        const G4DisplacedSolid* const disp = static_cast<const G4DisplacedSolid*>(right);
        assert( disp ); 
        X4AffineTransform xdirect(disp->GetDirectTransform()); 

        bool identityRotation = xdirect.isIdentityRotation() ; 

        const char* rot_id = identityRotation ? "NULL" : OTHER_ID->get(false) ;
        const char* tla_id = OTHER_ID->get(false) ;

        // TODO: suppress identity 
        std::string rot = identityRotation ? "" : xdirect.getRotationCode(rot_id);
        std::string tla = xdirect.getTranslationCode(tla_id);

        addG4Code(rot.c_str()) ;  
        addG4Code(tla.c_str()) ;  

        param.push_back( xright_displaced->getIdentifier() ); 
        param.push_back( rot_id ) ; 
        param.push_back( tla_id ) ; 
        keys.push_back( "right_id" );  
        keys.push_back( "rotation_id" );  
        keys.push_back( "translation_id" );  
    } 
    else
    {
        param.push_back( xright->getIdentifier() ); 
        keys.push_back( "right_id" );  
    }


    const std::vector<std::string> cparam(param); 
    const std::vector<std::string> ckeys(keys); 
    setG4Param(cparam, ckeys); 
}



OpticksCSG_t X4Solid::GetOperator( const G4BooleanSolid* solid ) // static
{
    OpticksCSG_t _operator = CSG_ZERO ; 
    if      (dynamic_cast<const G4IntersectionSolid*>(solid)) _operator = CSG_INTERSECTION ;
    else if (dynamic_cast<const G4SubtractionSolid*>(solid))  _operator = CSG_DIFFERENCE ;
    else if (dynamic_cast<const G4UnionSolid*>(solid))        _operator = CSG_UNION ;
    assert( _operator != CSG_ZERO ) ;

    LOG(LEVEL) 
        << " _operator " << _operator 
        << " CSG::Name " << CSG::Name(_operator) 
        ; 

    return _operator ; 
}





bool X4Solid::Contains( const char* s , char c ) // static 
{
    for(unsigned i=0 ; i < strlen(s) ; i++) if(s[i] == c) return true ; 
    return false ; 
}



const bool X4Solid::convertSphere_enable_phi_segment = SSys::getenvbool("X4Solid_convertSphere_enable_phi_segment"); 


/**
X4Solid::convertSphereDEV_
-----------------------------

When there is an inner radius as well as thetacut and phicut 
what is the appropriate/best way to arrange the CSG structure ? 
Perhaps a tree like::


                                              intersect                  
 
                       intersect                          phicut 
          
          diff                       thetacut 

     outer     inner 


TODO: make comparisons with Geant4 to see what is correct 


**/

nnode* X4Solid::convertSphereDEV_(const char* opt )
{
    LOG(fatal)
        << " USING DEV IMPLEMENTATION : TRIGGED BY SOLID NAME CONTAINING DEV " << m_name 
        ;

    const char* allopt = "RTP" ; 
    std::stringstream ss ; 
    ss << " opt " << opt ; 
    for(unsigned i=0 ; i < strlen(allopt) ; i++) ss << " " << allopt[i] << ":" << ( Contains(opt, allopt[i]) ? "+" : "-" ) ; 
   
    std::string desc = ss.str(); 
    LOG(info) << desc ; 

    const G4Sphere* const solid = static_cast<const G4Sphere*>(m_solid);

    float innerRadius = solid->GetInnerRadius()/mm ; 
    float outerRadius = solid->GetOuterRadius()/mm ; 
    bool has_inner = innerRadius > 0.f ;  

    nnode* outer = nsphere::Create( outerRadius );
    outer->label = BStr::concat(m_name, "_outer", NULL ) ; 

    nnode* inner = has_inner ? nsphere::Create( innerRadius ) : nullptr ;
    if(inner) 
    {
        inner->label = BStr::concat(m_name, "_inner", NULL ) ; 
        inner->complement = true ; 
    }

    LOG(LEVEL) 
        << " innerRadius " << innerRadius
        << " outerRadius " << outerRadius
        << " has_inner " << has_inner 
        ;


    double startTheta_pi = solid->GetStartThetaAngle()/(180.*degree) ; 
    double deltaTheta_pi = solid->GetDeltaThetaAngle()/(180.*degree) ; 
    bool has_thetacut = deltaTheta_pi < 1. ; 

    LOG(LEVEL) 
        << " startTheta_pi " << startTheta_pi
        << " deltaTheta_pi " << deltaTheta_pi
        << " has_thetacut " << has_thetacut
        ;

    double startPhi_pi = solid->GetStartPhiAngle()/(180.*degree) ; 
    double deltaPhi_pi = solid->GetDeltaPhiAngle()/(180.*degree) ; 
    bool has_phicut = deltaPhi_pi < 2. ; 

    LOG(LEVEL)
        << " startPhi_pi " << startPhi_pi
        << " deltaPhi_pi " << deltaPhi_pi
        << " has_phicut " << has_phicut
        ;
     

    enum { RADIUS, THETA, PHI } ; 

    bool enabled[3] ; 
    enabled[RADIUS] = Contains(opt, 'R'); 
    enabled[THETA]  = Contains(opt, 'T'); 
    enabled[PHI]    = Contains(opt, 'P'); 

    bool has[3] ; 
    has[RADIUS] = has_inner ; 
    has[THETA]  = has_thetacut ; 
    has[PHI]    = has_phicut ; 

    nnode* result = outer ; 
    
    for(unsigned i=0 ; i < strlen(opt) ; i++)
    {
        LOG(LEVEL) << " i " << i << " opt[i] " << opt[i] << " has[i] " << has[i] << " enabled[i] " << enabled[i]  ; 

        if( opt[i] == 'R' && has[i] && enabled[i] )
        {
            LOG(LEVEL) << " intersect with complemented inner " ; 
            result = nnode::make_operator(CSG_INTERSECTION, result, inner); 
        } 
        else if ( opt[i] == 'T' && has[i] && enabled[i] )
        {
            LOG(LEVEL) << " intersectWithThetaCut " ; 
            result = intersectWithThetaCut( result, startTheta_pi, deltaTheta_pi );  
        }
        else if ( opt[i] == 'P' && has[i] && enabled[i] )
        {
            LOG(LEVEL) << " intersectWithPhiCut " ; 
            result = intersectWithPhiCut(result, startPhi_pi, deltaPhi_pi );
        }
    }

    SetExternalBoundingBox(result, solid); 
    return result ; 
}


void X4Solid::SetExternalBoundingBox( nnode* root,  const G4VSolid* solid ) // static
{
    G4ThreeVector pMin ; 
    G4ThreeVector pMax ; 
    solid->BoundingLimits(pMin, pMax); 

    nbbox bb = {} ; 
    bb.min.x = pMin.x(); 
    bb.min.y = pMin.y(); 
    bb.min.z = pMin.z(); 

    bb.max.x = pMax.x(); 
    bb.max.y = pMax.y(); 
    bb.max.z = pMax.z(); 

    LOG(LEVEL) << "nnode::set_bbox using bb from G4VSolid::BoundingLimits " << bb.desc() ; 

    root->set_bbox( bb ); 
}



nnode* X4Solid::convertSphere_(bool only_inner)
{
    const G4Sphere* const solid = static_cast<const G4Sphere*>(m_solid);

    double rmin = solid->GetInnerRadius()/mm ; 
    double rmax = solid->GetOuterRadius()/mm ; 

    bool has_inner = !only_inner && rmin > 0. ; 
    nnode* inner = has_inner ? convertSphere_(true) : NULL ;  
    double radius = only_inner ? rmin : rmax ;   

    LOG(verbose) 
              << " radius : " << radius 
              << " only_inner : " << only_inner
              << " has_inner : " << has_inner 
              ;

    double startThetaAngle = solid->GetStartThetaAngle()/degree ; 
    double deltaThetaAngle = solid->GetDeltaThetaAngle()/degree ; 

    // z to the right, theta   0 -> z=r, theta 180 -> z=-r
    double rTheta = startThetaAngle ;
    double lTheta = startThetaAngle + deltaThetaAngle ;
    assert( rTheta >= 0. && rTheta <= 180.) ; 
    assert( lTheta >= 0. && lTheta <= 180.) ; 

    bool zslice = startThetaAngle > 0. || deltaThetaAngle < 180. ; 

    LOG(verbose) 
              << " rTheta : " << rTheta
              << " lTheta : " << lTheta
              << " zslice : " << zslice
              ;

    double x = 0. ; 
    double y = 0. ; 
    double z = 0. ; 

    nnode* cn = NULL ; 
    if(zslice)
    {
        double zmin = radius*std::cos(lTheta*CLHEP::pi/180.) ;
        double zmax = radius*std::cos(rTheta*CLHEP::pi/180.) ;
        assert( zmax > zmin ) ; 
        cn = nzsphere::Create( x, y, z, radius, zmin, zmax ) ;
        cn->label = BStr::concat(m_name, "_nzsphere", NULL) ; 
    }
    else
    {
        cn = nsphere::Create( x, y, z, radius );
        cn->label = BStr::concat(m_name, "_nsphere", NULL ) ; 
    }
    
    nnode* ret = has_inner ? nnode::make_operator(CSG_DIFFERENCE, cn, inner) : cn ; 
    if(has_inner) ret->label = BStr::concat(m_name, "_ndifference", NULL ) ; 
  

    double startPhi = solid->GetStartPhiAngle()/degree ; 
    double  deltaPhi = solid->GetDeltaPhiAngle()/degree ; 
    bool has_deltaPhi = deltaPhi < 360. ; 
    
    bool enable_phi_segment = convertSphere_enable_phi_segment ; 
    
    if(has_deltaPhi && !enable_phi_segment )
    {
        LOG(error) << " convertSphere_enable_phi_segment " << convertSphere_enable_phi_segment
                   << " has_deltaPhi " << has_deltaPhi
                   << " startPhi " << startPhi 
                   << " deltaPhi " << deltaPhi 
                   << " name " << m_name 
                   ;
    }

    double segZ = radius*1.01 ; 
    double segR = radius*1.5 ;   

    nnode* result =  has_deltaPhi && enable_phi_segment
                  ?
                     intersectWithPhiSegment(ret, startPhi, deltaPhi, segZ, segR ) 
                  :
                     ret 
                  ;

    return result ; 
}



/**
X4Solid::convertSphere
========================

Following ../analytic/gdml.py results in different nnode primitive subclasses 
or small nnode CSG trees depending on parameter values.
    
::
    
    nsphere 
    nzsphere 
       zsliced
    ndifference  
       handling rmin > 0 
    nintersection  
       when applying a phi segment

**/


void X4Solid::convertSphere()
{  
    const G4Sphere* const solid = static_cast<const G4Sphere*>(m_solid);
    assert(solid); 

    nnode* n = nullptr ; 

    if(strstr(m_name, "DEV") != nullptr)
    {
        const char* opt = SSys::getenvvar("X4Solid_convertSphereDEV_opt", "RTP") ;  
        n = convertSphereDEV_(opt); 
    }
    else
    {
        bool only_inner = false ; 
        n = convertSphere_(only_inner); 
    }
 
    setRoot(n); 


    std::vector<double> param = {
                                 solid->GetInnerRadius() ,
                                 solid->GetOuterRadius() ,
                                 solid->GetStartPhiAngle() ,
                                 solid->GetDeltaPhiAngle() ,
                                 solid->GetStartThetaAngle() ,
                                 solid->GetDeltaThetaAngle()
                               } ;

    std::vector<std::string> keys = {
                                      "innerRadius",
                                      "outerRadius",
                                      "startPhiAngle",
                                      "deltaPhiAngle",
                                      "startThetaAngle",
                                      "deltaThetaAngle"
                                  } ;  

    setG4Param(param,keys);
    setG4Args(param, keys);
}


void X4Solid::convertOrb()
{  
    const G4Orb* const solid = static_cast<const G4Orb*>(m_solid);
    assert(solid); 
    //LOG(info) << "\n" << *solid ; 

    float radius = solid->GetRadius()/mm ; 

    float x = 0.f ; 
    float y = 0.f ; 
    float z = 0.f ; 

    nnode* n =  nsphere::Create( x, y, z, radius );
    n->label = BStr::concat(m_name, "_sphere", NULL ) ; 

    setRoot(n); 

    std::vector<double> param  = { solid->GetRadius() } ;
    std::vector<std::string> keys  = { "radius" } ;

    setG4Param(param, keys); 
    setG4Args(param, keys);
}

void X4Solid::convertBox()
{  
    // cf ../analytic/gdml.py:Box

    const G4Box* const solid = static_cast<const G4Box*>(m_solid);
    assert(solid); 

    // match G4GDMLWriteSolids::BoxWrite
    float hx = solid->GetXHalfLength()/mm ; 
    float hy = solid->GetYHalfLength()/mm ; 
    float hz = solid->GetZHalfLength()/mm ; 

    float x = 2.0*hx ; 
    float y = 2.0*hy ; 
    float z = 2.0*hz ; 

    nnode* n =  nbox::Create( x, y, z,0.f, CSG_BOX3 );
    n->label = BStr::concat(m_name, "_box3", NULL ) ; 
    setRoot(n); 

    std::vector<double> param = { hx, hy, hz } ;
    std::vector<std::string> keys  = { "xHalfLength", "yHalfLength", "zHalfLength" } ;


    setG4Param(param, keys);
    setG4Args(param, keys);
}

/**
X4Solid::convertTubs_cylinder
--------------------------------

Suspicion that 1% nudge might not be enough of an expansion 
of the inner to avoid coincidences. 

With *do_inner_nudge=true* this expands inner-z by 1%, 
note that this does not change geometry : 
as are expanding the inner tube in z which are about to subtract away.
This is a simple way of avoiding CSG coincident constituent surface glitches.

However when the subtraction is subsequently subtracted this is 
suspected to cause spurious intersects, see
notes/issues/csg_sub_sub_spurious_intersects_on_elarged_inner_ghost_solid_bug.rst


**/

nnode* X4Solid::convertTubs_cylinder(bool do_nudge_inner)
{  
    const char* old_key = "X4Solid__convertTubs_cylinder_old_cylinder_implementation" ; 
    bool old_cylinder_implementation = SSys::getenvbool(old_key) ; 
    if(old_cylinder_implementation)
    {
        LOG(error) << " CAUTION old_cylinder_implementation enabled by envvar " << old_key ; 
    }

    const G4Tubs* const solid = static_cast<const G4Tubs*>(m_solid);
    assert(solid); 

    double rmin = solid->GetInnerRadius()/mm ; 
    double rmax = solid->GetOuterRadius()/mm ; 
    double hz = solid->GetZHalfLength()/mm ;  

    bool has_inner = rmin > 0. ; 

    LOG(LEVEL)
        << " rmin " << rmin
        << " rmax " << rmax
        << " hz " << hz
        << " has_inner " << has_inner
        << " do_nudge_inner " << do_nudge_inner
        << " old_cylinder_implementation " << old_cylinder_implementation
        ;
   
    nnode* inner = NULL ; 
    if(has_inner)
    {
        if( do_nudge_inner )
        { 
            double nudge_inner = 0.01 ; 
            double dz = hz*nudge_inner ;  
            inner = ncylinder::Create(rmin, -(hz+dz), (hz+dz), old_cylinder_implementation );   // radius, z1, z2    (z2 > z1)
        }
        else
        {
            inner = ncylinder::Create(rmin, -hz, hz, old_cylinder_implementation );         // radius, z1, z2    (z2 > z1)
        }
        inner->label = BStr::concat( m_name, "_inner", NULL ); 
    }

    nnode* outer = ncylinder::Create(rmax, -hz, hz, old_cylinder_implementation );
    outer->label = BStr::concat( m_name, "_outer", NULL ); 

    nnode* tube = has_inner ? nnode::make_operator(CSG_DIFFERENCE, outer, inner) : outer ; 
    tube->label = BStr::concat( m_name, "_difference", NULL );

    return tube ; 
}

const float X4Solid::hz_disc_cylinder_cut = 0.1f ; // was 1.0 until sep 11, 2022 : see notes/issues/ct_scan_nmskTailInner.rst

nnode* X4Solid::convertTubs_disc()
{  
    const G4Tubs* const solid = static_cast<const G4Tubs*>(m_solid);
    assert(solid); 
 
    float rmin = solid->GetInnerRadius()/mm ; 
    float rmax = solid->GetOuterRadius()/mm ; 
    float hz = solid->GetZHalfLength()/mm ;  

    assert( hz < hz_disc_cylinder_cut && "this is only applicable to very thin-in-z cylinders that can be regarded as discs" ) ; 

    nnode* tube = make_disc(rmin,rmax, -hz, hz);
    tube->label = BStr::concat( m_name, "_disc", NULL ); 

    return tube ; 
}

/**
X4Solid::convertTubs
---------------------

TODO: calculate what the segment prism segR size  should be rather 
than this adhoc choice.
As are intersecting it doesnt matter if the segR is too big, 
but being too small could result in partial segmenting of the base shape

Is 50% bigger than rmax always a safe choice ?

See also

* cf ../analytic/gdml.py:Tube


**/
void X4Solid::convertTubs()
{  
    const G4Tubs* const solid = static_cast<const G4Tubs*>(m_solid);
    assert(solid); 
    //LOG(info) << "\n" << *solid ; 

    // better to stay double until there is a need to narrow to float for storage or GPU 
    double hz = solid->GetZHalfLength()/mm ;  
    double  z = hz*2.0 ;   // <-- this full-length z is what GDML stores

    double startPhi = solid->GetStartPhiAngle()/degree ; 
    double deltaPhi = solid->GetDeltaPhiAngle()/degree ; 
    double rmax = solid->GetOuterRadius()/mm ; 

    bool pick_disc = hz < hz_disc_cylinder_cut ; 

    bool is_x4tubsnudgeskip = isX4TubsNudgeSkip()  ;
    bool do_nudge_inner = is_x4tubsnudgeskip ? false : true ;   // --x4tubsnudgeskip 0,1,2  # lvIdx of the tree 

    nnode* tube = pick_disc ? convertTubs_disc() : convertTubs_cylinder(do_nudge_inner) ; 

    bool deltaPhi_segment_enabled = true ; 
    bool has_deltaPhi = deltaPhi < 360. ; 


    double segZ = z*1.01 ; 
    double segR = rmax*1.5 ;   

    LOG(LEVEL)
        << " has_deltaPhi " << has_deltaPhi
        << " pick_disc " << pick_disc 
        << " deltaPhi_segment_enabled " << deltaPhi_segment_enabled
        << " is_x4tubsnudgeskip " << is_x4tubsnudgeskip
        << " do_nudge_inner " << do_nudge_inner
        ;

    nnode* result =  has_deltaPhi && deltaPhi_segment_enabled 
                  ?
                     intersectWithPhiSegment(tube, startPhi, deltaPhi, segZ, segR ) 
                  :
                     tube 
                  ;

    setRoot(result); 



    std::vector<double> param = { 
                                  solid->GetInnerRadius(), 
                                  solid->GetOuterRadius(), 
                                  solid->GetZHalfLength(), 
                                  solid->GetStartPhiAngle(),
                                  solid->GetDeltaPhiAngle() 
                               } ;

    std::vector<std::string> keys = { 
                                  "innerRadius", 
                                  "outerRadius", 
                                  "zHalfLength", 
                                  "startPhiAngle",
                                  "deltaPhiAngle" 
                               } ;

    setG4Param(param, keys);
    setG4Args(param, keys);
}




/**
X4Solid::intersectWithPhiCut
---------------------------------

**/

nnode* X4Solid::intersectWithPhiCut(nnode* whole, double startPhi_pi, double deltaPhi_pi)  
{
    nnode* phicut = nphicut::Create( startPhi_pi, deltaPhi_pi ); 
    phicut->label = BStr::concat(m_name, "_phicut_wedge", NULL); 

    nnode* result = nnode::make_operator(CSG_INTERSECTION, whole, phicut); 
    result->label = BStr::concat(m_name, "_phicut_intersection", NULL); 

    return result ; 
}


/**
X4Solid::intersectWithThetaCut
---------------------------------

**/

nnode* X4Solid::intersectWithThetaCut(nnode* whole, double startTheta_pi, double deltaTheta_pi)  
{
    nnode* thetacut = nthetacut::Create( startTheta_pi, deltaTheta_pi ); 
    thetacut->label = BStr::concat(m_name, "_thetacut_wedge", NULL); 

    nnode* result = nnode::make_operator(CSG_INTERSECTION, whole, thetacut ); 
    result->label = BStr::concat(m_name, "_thetacut_intersection", NULL); 

    return result ; 
}





/**
X4Solid::intersectWithPhiSegment
---------------------------------

* intersects with a cheesy wedge convexpolyhedron 

* CAUTION : THIS CODE HAS SEEN LITTLE REAL WORLD USE AND IS POORLY TESTED

* suffers degeneracy collapse from segment to a plane when deltaPhi = 180, 
  in an attempt to cope with this a box in used rather than the convexpolyhedron  
  

**/
const int X4Solid::intersectWithPhiSegment_debug_mode = SSys::getenvint("X4Solid_intersectWithPhiSegment_debug_mode", 0); 

nnode* X4Solid::intersectWithPhiSegment(nnode* whole, float startPhi, float deltaPhi, float segZ, float segR )  
{
    int debug_mode = intersectWithPhiSegment_debug_mode  ;
    int debug_minor = debug_mode % 10 ; 
    int debug_major = debug_mode / 10 ; 
 
    LOG(error)
        << " startPhi " << startPhi
        << " deltaPhi " << deltaPhi
        << " segZ " << segZ
        << " segR " << segR
        << " debug_mode " << debug_mode
        << " debug_minor " << debug_minor
        << " debug_major " << debug_major
        ;


    bool has_deltaphi = deltaPhi < 360.f ; 
    assert( has_deltaphi ) ; 

    nnode* segment = NULL ; 
  
    if( startPhi == 0.f && deltaPhi == 180.f )
    {
        LOG(error) << " special cased startPhi == 0.f && deltaPhi == 180.f " ; 

        // pure guesswork starting point : need some visualization guidance 

        nbbox bb = whole->bbox();
        float sx = bb.max.x - bb.min.x ; 
        float sy = bb.max.y - bb.min.y ; 
        float sz = bb.max.z - bb.min.z ; 

        segment = nbox::Create(sx,sy,sz,0.f, CSG_BOX3);  
        //segment.transform = nmat4triple::make_transform(
        segment->label = BStr::concat(m_name, "_segment_box", NULL); 
    }
    else
    {
        float phi0 = startPhi ; 
        float phi1 = startPhi + deltaPhi ; 
        float u_segZ = segZ ;  

        if( debug_major == 1 )
        {
            u_segZ = segZ/2. ; 
 
            LOG(error) 
                << " reproduce segZ half sized bug "
                << " segZ " << segZ 
                << " u_segZ " << u_segZ 
                ; 
        } 

        segment = nconvexpolyhedron::CreateSegment(phi0, phi1, u_segZ, segR );  
        segment->label = BStr::concat(m_name, "_segment_wedge", NULL); 
    }

    nnode* result = nnode::make_operator(CSG_INTERSECTION, whole, segment); 
    result->label = BStr::concat(m_name, "_intersection", NULL); 



    if( debug_minor == 1 ) 
    {
        LOG(error) << "X4Solid_intersectWithPhiSegment_debug_mode debug_minor " << debug_minor << " RETURNING SEGMENT " ; 
        result = segment ; 
        result->label = BStr::concat(m_name, "_debug_segment", NULL); 
    }
    else if( debug_minor == 2 ) 
    {
        LOG(error) << "X4Solid_intersectWithPhiSegment_debug_mode debug_minor " << debug_minor << " RETURNING UNION " ; 
        result = nnode::make_operator(CSG_UNION, whole, segment); 
        result->label = BStr::concat(m_name, "_debug_union", NULL); 
    }
    else if( debug_minor == 3 ) 
    {
        LOG(error) << "X4Solid_intersectWithPhiSegment_debug_mode debug_minor " << debug_minor << " RETURNING DIFFERENCE " ; 
        result = nnode::make_operator(CSG_DIFFERENCE, whole, segment); 
        result->label = BStr::concat(m_name, "_debug_difference", NULL); 
    }
    else if( debug_minor == 4 ) 
    {
        LOG(error) << "X4Solid_intersectWithPhiSegment_debug_mode debug_minor " << debug_minor << " RETURNING INTERSECT " ; 
        result = nnode::make_operator(CSG_INTERSECTION, whole, segment); 
        result->label = BStr::concat(m_name, "_debug_intersect", NULL); 
    }


    return result ; 
}

void X4Solid::convertTrd()
{  
/**
Following 

* G4GDMLWriteSolids::TrdWrite
* ../analytic/gdml.py 
* ../analytic/prism.py 

**/
    const G4Trd* const solid = static_cast<const G4Trd*>(m_solid);
    assert(solid); 

    float x1 = 2.0*solid->GetXHalfLength1()/mm ;
    float x2 = 2.0*solid->GetXHalfLength2()/mm ; 
    float y1 = 2.0*solid->GetYHalfLength1()/mm ; 
    float y2 = 2.0*solid->GetYHalfLength2()/mm ; 
    float z = 2.0*solid->GetZHalfLength()/mm ; 

    nnode* trd = nconvexpolyhedron::CreateTrapezoid(z, x1, y1, x2, y2 ); 
    trd->label = BStr::concat(m_name, "_solid", NULL ); 

    setRoot(trd); 

    std::vector<double> param = { solid->GetXHalfLength1() , 
                                 solid->GetXHalfLength2() , 
                                 solid->GetYHalfLength1() ,
                                 solid->GetYHalfLength2() ,
                                 solid->GetZHalfLength()  } ;  

    std::vector<std::string> keys = {
                                    "xHalfLength1",  
                                    "xHalfLength2",  
                                    "yHalfLength1",  
                                    "yHalfLength2",  
                                    "zHalfLength"
                                   } ;   

    setG4Param(param, keys);
    setG4Args(param, keys);
}

/**
X4Solid::convertCons_
----------------------

startPhi/deltaPhi is implemented using X4Solid::intersectWithPhiSegment

TODO
    calculate what the segment prism segR size  should be rather 
    than this adhoc choice.
    As are intersecting it doesnt matter if the segR is too big, 
    but being too small could result in partial segmenting of the base shape
    
    Is 50% bigger than rmax always a safe choice ?

See also:

* G4GDMLWriteSolids::ConeWrite


**/

nnode* X4Solid::convertCons_(bool only_inner)
{
    const G4Cons* const cone = static_cast<const G4Cons*>(m_solid);
    assert(cone); 

    float rmax1    = cone->GetOuterRadiusMinusZ()/mm ;
    float rmax2    = cone->GetOuterRadiusPlusZ()/mm  ;

    float rmin1    = cone->GetInnerRadiusMinusZ()/mm ;
    float rmin2    = cone->GetInnerRadiusPlusZ()/mm  ;

    float z        = 2.0*cone->GetZHalfLength()/mm   ;
    float startPhi = cone->GetStartPhiAngle()/degree ;
    float deltaPhi = cone->GetDeltaPhiAngle()/degree ;

    bool has_inner = !only_inner && (rmin1 > 0.f || rmin2 > 0.f) ; 
    nnode* inner = has_inner ? convertCons_(true) : NULL ; 

    float r1 = only_inner ? rmin1 : rmax1 ; 
    float r2 = only_inner ? rmin2 : rmax2 ; 
    float z1 = -z/2.0 ; 
    float z2 = z/2.0 ; 

    nnode* cn = make_cone(r1,z1,r2,z2) ;
    cn->label = BStr::concat(m_name, "_cn", NULL ) ; 

    nnode* ret = has_inner ? nnode::make_operator(CSG_DIFFERENCE, cn, inner) : cn ; 
    if(has_inner) ret->label = BStr::concat(m_name, "_ndifference", NULL ) ; 

    bool deltaPhi_segment_enabled = true ; 
    bool has_deltaPhi = deltaPhi < 360.f ; 

    float segZ = z*1.01 ; 
    float segR = std::max(rmax1, rmax2)*1.5 ;   

    nnode* result =  has_deltaPhi && deltaPhi_segment_enabled 
                  ?
                     intersectWithPhiSegment(ret, startPhi, deltaPhi, segZ, segR ) 
                  :
                     ret 
                  ;

    return result ; 
}

void X4Solid::convertCons()
{  
    const G4Cons* const solid = static_cast<const G4Cons*>(m_solid);
    assert(solid); 
    //LOG(info) << "\n" << *solid; 

    bool only_inner = false ; 
    nnode* n = convertCons_(only_inner); 
    setRoot(n); 

    std::vector<double> param = {  
                                  solid->GetInnerRadiusMinusZ() ,  
                                  solid->GetOuterRadiusMinusZ() ,  
                                  solid->GetInnerRadiusPlusZ()  ,  
                                  solid->GetOuterRadiusPlusZ()  ,
                                  solid->GetZHalfLength() , 
                                  solid->GetStartPhiAngle() , 
                                  solid->GetDeltaPhiAngle() 
                               } ;

    std::vector<std::string> keys = {
                                  "innerRadiusMinusZ" ,  
                                  "outerRadiusMinusZ" ,  
                                  "innerRadiusPlusZ"  ,  
                                  "outerRadiusPlusZ"  ,
                                  "zHalfLength" , 
                                  "startPhiAngle" , 
                                  "deltaPhiAngle"
                                   } ; 

    setG4Param(param, keys );
    setG4Args(param, keys);
}

void X4Solid::convertTorus()
{  
    const G4Torus* const solid = static_cast<const G4Torus*>(m_solid);
    assert(solid); 

    // G4GDMLWriteSolids::TorusWrite

    float rmin = solid->GetRmin()/mm ; 
    float rmax = solid->GetRmax()/mm ;
    float rtor = solid->GetRtor()/mm ;
    float startPhi = solid->GetSPhi()/degree ; 
    float deltaPhi = solid->GetDPhi()/degree ; 

    LOG(LEVEL) 
       << " [ convertTorus "
       << " rmin(mm) " << rmin
       << " rmax(mm) " << rmax
       << " rtor(mm) " << rtor
       << " startPhi(deg) " << startPhi
       << " deltaPhi(deg) " << deltaPhi
       ; 


    if( startPhi < 0 ) 
    {
        LOG(fatal) 
           <<  " changing torus -ve startPhi (degrees) to zero " << startPhi 
           ;
         startPhi = 0.f ; 
    } 

    if( deltaPhi != 360.f ) 
    {
        LOG(fatal) 
           <<  " changing torus deltaPhi (degrees) to 360 " << deltaPhi 
           ;
         deltaPhi = 360.f ; 
    } 


    LOG(LEVEL) 
       << " ] convertTorus "
       << " rmin(mm) " << rmin
       << " rmax(mm) " << rmax
       << " rtor(mm) " << rtor
       << " startPhi(deg) " << startPhi
       << " deltaPhi(deg) " << deltaPhi
       ; 


    assert( rmin == 0.f ); // torus with rmin not yet handled 
    assert( startPhi == 0.f && deltaPhi == 360.f ); 

    float r = rmax ; 
    float R = rtor ; 
    assert( R > r ); 

    nnode* n = make_torus(R, r) ;
    n->label = BStr::concat( m_name , "_torus" , NULL ); 
    setRoot(n); 

    std::vector<double> param = {  
                                  solid->GetRmin() ,  
                                  solid->GetRmax() ,  
                                  solid->GetRtor()  ,  
                                  solid->GetSPhi()  ,
                                  solid->GetDPhi()  
                               } ;

    std::vector<std::string> keys = {
                                  "rmin" ,  
                                  "rmax" ,  
                                  "rtor"  ,  
                                  "sPhi"  ,
                                  "dPhi"  
                                 } ; 

    setG4Param(param, keys);
    setG4Args(param, keys);
}

/**
X4Solid::convertEllipsoid
--------------------------

Implemented using a sphere with an associated scale transform.
The sphere radius is picked to be the ZSemiAxis with scale factors being::

    ( XSemiAxis/ZSemiAxis, YSemiAxis/ZSemiAxis, ZSemiAxis/ZSemiAxis )
    ( XSemiAxis/ZSemiAxis, YSemiAxis/ZSemiAxis, 1. )
 
This means that for a PMT bulb like shape flattened in Z the scale factors might be::

     ( 1.346, 1.346, 1.00 )

So the underlying sphere is being expanded equally in x and y directions
with z unscaled.   

**/

void X4Solid::convertEllipsoid()
{  
    const G4Ellipsoid* const solid = static_cast<const G4Ellipsoid*>(m_solid);
    assert(solid); 

    // G4GDMLWriteSolids::EllipsoidWrite

    double ax = solid->GetSemiAxisMax(0)/mm ; 
    double by = solid->GetSemiAxisMax(1)/mm ; 
    double cz = solid->GetSemiAxisMax(2)/mm ; 

    glm::tvec3<double> scale( ax/cz, by/cz, 1.) ;   // unity scaling in z, so z-coords are unaffected  
 
    double zcut1 = solid->GetZBottomCut()/mm ; 
    double zcut2 = solid->GetZTopCut()/mm ;

    double z1 = zcut1 > -cz ? zcut1 : -cz ; 
    double z2 = zcut2 <  cz ? zcut2 :  cz ; 
    assert( z2 > z1 ) ;  

    bool upper_cut = z2 < cz ; 
    bool lower_cut = z1 > -cz ; 
    bool zslice = lower_cut || upper_cut ; 

    LOG(LEVEL) 
         << " upper_cut " << upper_cut 
         << " lower_cut " << lower_cut 
         << " zcut1 " << zcut1 
         << " zcut2 " << zcut2
         << " z1 " << z1
         << " z2 " << z2
         << " ax " << cz
         << " by " << cz
         << " cz " << cz
         << " zslice " << zslice
         ;

    nnode* cn = nullptr ; 
    if( upper_cut == false && lower_cut == false )
    {
        cn =  (nnode*)nsphere::Create( 0.f, 0.f, 0.f, cz ) ; 
    }
    else if( upper_cut == true && lower_cut == true )
    {
        cn = (nnode*)nzsphere::Create( 0.f, 0.f, 0.f, cz, z1, z2 )  ; 
    }
    else if ( upper_cut == false && lower_cut == true )   // PMT mask uses this 
    {
        double z2_safe = z2 + 0.1 ;  // trying to avoid the apex bug 
        cn = (nnode*)nzsphere::Create( 0.f, 0.f, 0.f, cz, z1, z2_safe )  ; 
        // when there is no upper cut avoid the placeholder upper cut from ever doing anything by a safety offset
        // see notes/issues/unexpected_zsphere_miss_from_inside_for_rays_that_would_be_expected_to_intersect_close_to_apex.rst
    }
    else if ( upper_cut == true && lower_cut == false )
    {
        double z1_safe = z1 - 0.1 ; // also avoid analogous nadir bug 
        cn = (nnode*)nzsphere::Create( 0.f, 0.f, 0.f, cz, z1_safe, z2 )  ; 
        // when there is no lower cut avoid the placeholder lower cut from ever doing anything by a safety offset
        // see notes/issues/unexpected_zsphere_miss_from_inside_for_rays_that_would_be_expected_to_intersect_close_to_apex.rst
    }


    cn->label = BStr::concat(m_name, "_ellipsoid", NULL) ; 
    cn->transform = nmat4triple::make_scale( scale );
    
    LOG(LEVEL) 
         << std::endl  
         << gpresent("tr.t", cn->transform->t ) 
         << std::endl  
         << gpresent("tr.v", cn->transform->v )  
         << std::endl  
         << gpresent("tr.q", cn->transform->q ) 
         << std::endl  
         ;

    setRoot(cn); 

    std::vector<double> param = {  
                                  solid->GetSemiAxisMax(0) ,  
                                  solid->GetSemiAxisMax(1) ,  
                                  solid->GetSemiAxisMax(2) ,  
                                  solid->GetZBottomCut()  ,
                                  solid->GetZTopCut()  
                               } ;

    std::vector<std::string> keys = {
                                  "semiAxisMaxX" ,  
                                  "semiAxisMaxY" ,  
                                  "semiAxisMaxZ" ,  
                                  "zBottomCut"  ,
                                  "zTopCut"
                                  } ;  

    setG4Param(param, keys);
    setG4Args(param, keys);
}




const bool X4Solid::convertPolycone_enable_phi_segment = false ; 

/**
X4Solid::convertPolycone
--------------------------

Note that phi segmented polycones are not handled. 

See also:

* G4GDMLWriteSolids::PolyconeWrite
* G4GDMLWriteSolids::ZplaneWrite
* ../analytic/gdml.py 

**/

void X4Solid::Polycone_GetZPlane(std::vector<zplane>& zp, std::set<double>& R_inner, std::set<double>& R_outer, const G4PolyconeHistorical* ph  )
{
    unsigned nz = ph->Num_z_planes ; 
    zp.resize(nz); 
    for (int i=0; i < int(nz) ; i++) 
    {
        zp[i] = { ph->Rmin[i], ph->Rmax[i], ph->Z_values[i] } ;  
        R_inner.insert(ph->Rmin[i]); 
        R_outer.insert(ph->Rmax[i]); 
    }
}


bool X4Solid::Polycone_CheckZOrder( const std::vector<zplane>& zp, bool z_ascending )
{
    int count_z_order = 0 ; 
    int nz = int(zp.size()); 
    for( int i=1 ; i < nz ; i++)
    {
        bool z_order = z_ascending ? zp[i-1].z <= zp[i].z : zp[i].z <= zp[i-1].z ; 
        if(z_order) count_z_order += 1 ; 
    }
    bool all_z_order = count_z_order == nz - 1 ;  // -1 as pairs 
    return all_z_order ; 
}

bool X4Solid::Polycone_DoPhiSegment( const G4PolyconeHistorical* ph )
{
    const bool enable_phi_segment = convertPolycone_enable_phi_segment ; 
    double startPhi = ph->Start_angle/degree ;  
    double deltaPhi = ph->Opening_angle/degree ;

    bool  has_phi_segment  = deltaPhi < 360.f  ; 

    if(enable_phi_segment == false)
    { 
        LOG_IF(error, has_phi_segment ) 
            << " startPhi " << startPhi
            << " deltaPhi " << deltaPhi
            << " skipped has_phi_segment == false assert " 
            ; 
        //assert( !has_phi_segment ); 
    }

    bool do_phi_segment = has_phi_segment && enable_phi_segment ; 
    return do_phi_segment ; 
}

/**
X4Solid::Polycone_MakePrims
-----------------------------

When making the inner need a way to expand outwards one side of the bookend prims 
in z for coincidence avoidance

* easy for to expand cylinders in z
* for cone have to avoid changing the shape by appropriate scaling of the radius

**/

void X4Solid::Polycone_MakePrims( const std::vector<zplane>& zp,  std::vector<nnode*>& prims, const char* name, bool outer  )
{
    for( unsigned i=1 ; i < zp.size() ; i++ )
    {
        const zplane& zp1 = zp[i-1] ;   // zplane struct rmin, rmax, z
        const zplane& zp2 = zp[i] ; 
        double r1 = outer ? zp1.rmax : zp1.rmin ; 
        double r2 = outer ? zp2.rmax : zp2.rmin ; 
        double z1 = zp1.z ; 
        double z2 = zp2.z ; 

        if( z1 == z2 )
        {
            //LOG(warning) << " skipping z2 == z1 zp " ; 
            continue ; 
        }
        
        bool z_ascending = z2 > z1 ; 
        LOG_IF(fatal, !z_ascending) << " !z_ascending " 
            << " z1 " << z1  
            << " z2 " << z2
            ;  
        assert(z_ascending); 

        nnode* n = NULL ; 
        if( r2 == r1 )
        { 
            n = ncylinder::Create(r2, z1, z2);
            n->label = BStr::concat<unsigned>( name, i-1, "_zp_cylinder" ); 
        }
        else
        {
            n = make_cone(r1,z1,r2,z2) ;
            n->label = BStr::concat<unsigned>(name, i-1 , "_zp_cone" ) ; 
        }
        prims.push_back(n); 
    }   // over pairs of planes
}


const int X4Solid::convertPolycone_debug_mode = SSys::getenvint("X4Solid_convertPolycone_debug_mode", 0); 

void X4Solid::convertPolycone()
{  
    const int debug_mode = convertPolycone_debug_mode ; 

    const G4Polycone* const polycone = static_cast<const G4Polycone*>(m_solid);
    assert(polycone); 
    const G4PolyconeHistorical* ph = polycone->GetOriginalParameters() ;
    double startPhi = ph->Start_angle/degree ;  
    double deltaPhi = ph->Opening_angle/degree ;

    std::vector<zplane> zp ; 
    std::set<double> R_inner ; 
    std::set<double> R_outer ; 
    Polycone_GetZPlane(zp, R_inner, R_outer, ph ) ; 

    bool all_z_descending = Polycone_CheckZOrder(zp, false ); 
    if(all_z_descending)
    {
        LOG(error) << "all_z_descending detected, reversing " << m_name ; 
        std::reverse( std::begin(zp), std::end(zp) ) ; 
    } 
    bool all_z_ascending  = Polycone_CheckZOrder(zp, true  ); 
    assert( all_z_ascending ); 

    bool do_phi_segment = Polycone_DoPhiSegment(ph); 

    unsigned nz = zp.size() ; 
    double zmin = zp[0].z ; 
    double zmax = zp[nz-1].z ; 

    double R_inner_min = *R_inner.begin() ; 
    double R_inner_max = *R_inner.begin() ; 
    for(std::set<double>::const_iterator it = R_inner.begin() ; it != R_inner.end() ; it++ ) 
    {
        R_inner_min = std::min( R_inner_min, *it );
        R_inner_max = std::max( R_inner_max, *it );
    }

    bool no_inner = R_inner_min == 0. && R_inner_max == 0. ; 
    bool has_inner = !no_inner ; 


    double R_outer_min = *R_outer.begin() ; 
    double R_outer_max = *R_outer.begin() ; 
    for(std::set<double>::const_iterator it = R_outer.begin() ; it != R_outer.end() ; it++ ) 
    {
        R_outer_min = std::min( R_outer_min, *it );
        R_outer_max = std::max( R_outer_max, *it );
    }

    unsigned num_R_inner = R_inner.size() ; 
    unsigned num_R_outer = R_outer.size() ; 

    LOG(LEVEL)
        << " nz " << nz
        << " zmin " << std::setw(10) << std::fixed << std::setprecision(4) << zmin
        << " zmax " << std::setw(10) << std::fixed << std::setprecision(4) << zmax
        << " do_phi_segment " << do_phi_segment 
        ;

    LOG(LEVEL)
        << " R_inner_min  " << std::setw(10) << std::fixed << std::setprecision(4) << R_inner_min
        << " R_inner_max  " << std::setw(10) << std::fixed << std::setprecision(4) << R_inner_max
        << " num_R_inner " << num_R_inner
        << " has_inner " << has_inner 
        ;
    LOG(LEVEL)
        << " R_outer_min  " << std::setw(10) << std::fixed << std::setprecision(4) << R_outer_min
        << " R_outer_max  " << std::setw(10) << std::fixed << std::setprecision(4) << R_outer_max
        << " num_R_outer " << num_R_outer
        ;


    double segZ = (zmax-zmin)*1.01 ; 
    double segR = R_outer_max*1.5 ;   



    std::vector<nnode*> outer_prims ; 
    Polycone_MakePrims( zp, outer_prims, m_name, true  ); 
    bool dump = false ; 
    nnode* outer = NTreeBuilder<nnode>::UnionTree(outer_prims, dump) ;


    nnode* inner = NULL ; 
    if(has_inner && num_R_inner == 1)
    {
        double rmin = R_inner_min ; 
        assert( R_inner_min == R_inner_max ); 

        inner = ncylinder::Create(rmin, zmin, zmax);
        inner->label = BStr::concat( m_name, "_inner_cylinder", NULL  ); 
    }
    else if( has_inner && num_R_inner > 1 )
    {
        inner = Polycone_MakeInner( zp, m_name, num_R_inner ); 
        inner->label = BStr::concat( m_name, "_inner_polycone", NULL  ); 
    }

    nnode* result = inner ? nnode::make_operator(CSG_DIFFERENCE, outer, inner ) : outer  ; 

    nnode* end_result =  do_phi_segment
                      ?
                         intersectWithPhiSegment(result, startPhi, deltaPhi, segZ, segR ) 
                      :
                         result 
                      ;

    if( debug_mode > 0 )
    {
        LOG(error) << " X4Solid_convertPolycone_debug_mode " << debug_mode ; 
        switch(debug_mode)
        {
            case 1: end_result = inner ; break ; 
            case 2: end_result = outer ; break ; 
        }
    }

    setRoot(end_result); 
    convertPolycone_g4code();
}

/**
X4Solid::Polycone_MakeInner
----------------------------

* see j/issues/base_steel_multiple_Rmin_is_unhandled.rst

**/

nnode* X4Solid::Polycone_MakeInner(const std::vector<zplane>& zp, const char* name, unsigned num_R_inner) // static 
{
    LOG(fatal) << " EXPERIMENTAL num_R_inner > 1 handling "  << name << " num_R_inner " << num_R_inner  ;   

    std::vector<nnode*> inner_prims ; 
    Polycone_MakePrims( zp, inner_prims, name, false  ); 

    unsigned num_prims = inner_prims.size() ; 
    LOG(error) << " inner_prims.size " << num_prims ; 

    nnode* lower = inner_prims[0] ; 
    nnode* upper = inner_prims[inner_prims.size()-1] ; 

    if( lower->is_znudge_capable() &&  upper->is_znudge_capable()  )
    {
        float dz = 1.0 ; 

        LOG(error) << " lower.is_znudge_capable " ; 
        lower->decrease_z1(dz); 

        LOG(error) << " upper.is_znudge_capable " ;  
        upper->increase_z2(dz); 

        if( num_prims == 2 )
        {
            // see NNodeNudger::znudge_union_maxmin  expand the z on the smaller r side

            nnode* j = upper ; 
            nnode* i = lower ; 

            float rj = j->r1() ; 
            float ri = i->r2() ;  

            if( ri > rj )    
            {   
               /** 
                          rj
                    +-----+
                    |     |   
                +---+-----+---+
                |   +~~~~~+   |    j->decrease_z1
                |             | 
                +-------------+
                              ri 
                **/ 

                j->decrease_z1( dz );   
            }   
            else
            {   


               /** 
                              rj                 
                +-------------+
                |             |
                |   +~~~~~+   |    i->increase_z2
                +---+-----+---+
                    |     |   
                    +-----+             
                          ri         

                **/ 

                i->increase_z2( dz );  
            }   
        }
        else
        {
            LOG(fatal) << " polycone inner coincidence avoidance has not yet been generalized, name " << name  ;  
        }
    }

    LOG(error) << " after znudges " ; 
    bool inner_dump = true ; 
    nnode* inner = NTreeBuilder<nnode>::UnionTree(inner_prims, inner_dump) ;
    return inner ; 
}




void X4Solid::convertPolycone_g4code()
{
    const G4Polycone* const so = static_cast<const G4Polycone*>(m_solid);
    assert(so); 
    const G4PolyconeHistorical* ph = so->GetOriginalParameters() ;

    std::vector<std::string> param ;

    double startPhi = so->GetStartPhi() ; 
    double endPhi = so->GetEndPhi() ; 

    double phiStart = startPhi ;   
    double phiTotal = endPhi - startPhi ; 
    unsigned numZPlanes = ph->Num_z_planes ; 

    param.push_back( X4::Value(phiStart) ); 
    param.push_back( phiTotal < CLHEP::twopi ? X4::Value(phiTotal) : "CLHEP::twopi" ); 
    param.push_back( X4::Value(numZPlanes) ); 

    const char* zPlane_id = OTHER_ID->get(false) ; 
    const char* rInner_id = OTHER_ID->get(false) ; 
    const char* rOuter_id = OTHER_ID->get(false) ; 

    std::string zPlane = X4::Array(ph->Z_values, numZPlanes , zPlane_id ) ;
    std::string rInner = X4::Array(ph->Rmin    , numZPlanes , rInner_id ) ;
    std::string rOuter = X4::Array(ph->Rmax    , numZPlanes , rOuter_id ) ;

    addG4Code( zPlane.c_str() ); 
    addG4Code( rInner.c_str() ); 
    addG4Code( rOuter.c_str() ); 

    param.push_back( zPlane_id ) ;  
    param.push_back( rInner_id ) ;  
    param.push_back( rOuter_id ) ;  

    std::vector<std::string> keys = { 
                "phiStart",
                "phiTotal",
                "numZPlanes",
                "zPlane_id", 
                "rInner_id", 
                "rOuter_id" 
               } ; 

    setG4Param(param, keys );
    // no setG4args for the string ones
} 


void X4Solid::convertHype()
{  
    const G4Hype* const solid = static_cast<const G4Hype*>(m_solid);
    assert(solid); 
    LOG(info) << "\n" << *solid ; 

    bool only_inner = false ; 
    nnode* n = convertHype_(only_inner); 
    setRoot(n); 

    std::vector<double> param = {
                                  solid->GetInnerRadius(),
                                  solid->GetOuterRadius(),
                                  solid->GetInnerStereo(),
                                  solid->GetOuterStereo(),
                                  solid->GetZHalfLength()
                                } ;

    std::vector<std::string> keys = {
                                  "innerRadius",
                                  "outerRadius",
                                  "innerStereo",
                                  "outerStereo",
                                  "zHalfLength"
                                } ;
 
    setG4Param(param, keys);
    setG4Args(param, keys);
}

/**
X4Solid::convertHype_
------------------------

Opticks CSG_HYPERBOLOID uses::

    x^2 +  y^2  =  r0^2 * (  (z/zf)^2  +  1 )

G4Hype uses::

    x^2 + y^2 = (z*tanphi)^2 + r^2
    x^2 + y^2 =  r0^2 * ( (z*tanphi/r0)^2 + 1 )

So::

    tanphi/r0 = 1/zf
    zf = r0/tanphi
    tanphi = r0/zf
    phi = arctan(r0/zf)


See also:

* G4GDMLWriteSolids::HypeWrite

**/

nnode* X4Solid::convertHype_(bool only_inner)
{
    const G4Hype* const solid = static_cast<const G4Hype*>(m_solid);

    float rmin = solid->GetInnerRadius()/mm ; 
    float rmax = solid->GetOuterRadius()/mm ;
    float inst = solid->GetInnerStereo()/degree ; 
    float outst = solid->GetOuterStereo()/degree ;
    float z = 2.0*solid->GetZHalfLength()/mm ; 

    bool has_inner = !only_inner && rmin > 0.f ; 

    nnode* inner = has_inner ? convertHype_(true) : NULL ;  

    float radius = only_inner ? rmin : rmax ;   
    float stereo = only_inner ? inst : outst ; 
    float zf = radius/std::tan(stereo*CLHEP::pi/180.) ;
    float z2 =  z/2.0 ; 
    float z1 = -z/2.0 ;
 
    nnode* cn = make_hyperboloid( radius, zf, z1, z2 );
    cn->label = BStr::concat(m_name, "_hyperboloid", NULL ) ; 
    
    nnode* result = inner ? nnode::make_operator(CSG_DIFFERENCE, cn, inner )  : cn ; 
    return result ; 
}


