oc-source(){ echo $BASH_SOURCE ; }
oc-vi(){ vi $(oc-source) ; }
oc-env(){  olocal- ; opticks- ; }
oc-help(){ cat << EOH

opticks-config
===============

Provides cflags, libs and lippath for all opticks externals
and sub-packages based on underlying pkg-config .pc files
which are generated from the Opticks CMake/bash infrastructure.  

This allows C++ code using any of the Opticks packages to 
be compiled, linked and executed without using CMake.  
Many demonstrations of usage are in examples/Use*NoCMake/go.sh  

Usage examples:

    opticks-config --cflags NPY
    opticks-config --libs   NPY
    opticks-config --libpath NPY

Both opticks-config and oc are symbolic links to oc.bash::

    oc -cflags NPY
    oc -f NPY
    oc -f npy 
    oc --help

The pkg arguments are names such as NPY, optix, OptiXRap, PLog, G4
which are intepreted case insensitively.
If the pkg name is not recognized an error message from 
pkg-config is returned.


    oc-pkg-config-path : $(oc-pkg-config-path)


EOH
}

oc-pc-notes(){ cat << EON

pc generation for each of the externals 
------------------------------------------

The pc functions for externals are run following install 
by the double slash function eg glm--. They can also 
all be run by opticks-externals-pc 

HMM: where is the canonical place for preqs-pc ?

opticks-preqs-pc
~~~~~~~~~~~~~~~~~~

cuda
   bash generated in cuda-pc-
optix
   bash generated in optix-pc-

opticks-externals-pc
~~~~~~~~~~~~~~~~~~~~~

bcm
    placeholder as purely CMake level  
glm
    bash generation in glm-pc- NOT using oc-variables-
glfw
    generated by GLFW CMake then modified by glfw-pc
glew
    generated by GLEW Makefile with sed then modified by glew-pc 
    on macOS a "Requires: glu" causes failure, commented with glew-pc-unglu
gleq
    just a placed header, gleq-pc placeholder only
imgui
    bash generation in imgui-pc- using oc-variables-
assimp
    generated by Assimp CMake then modified by assimp-pc
openmesh
    bash generation in openmesh-pc- using oc-variables-
plog
    bash generation in plog-pc- NOT using oc-variables-
opticksaux
    placeholder
oimplicitmesher
    generated by CMake/BCM, oimplicitmesher-pc is placeholder
odcs
    generated by CMake/BCM, odcs-pc is placeholder
oyoctogl
    generated by CMake/BCM, oyoctogl-pc is placeholder
ocsgbsp
    generated by CMake/BCM, ocsgbsp-pc is placeholder
xercesc
    on macOS xerces-c comes from macports 
    modified by xercesc-pc 
g4
    bash generation in g4-pc- NOT using oc-variables-

EON
}


oc-usage(){ cat << EOU

opticks-config notes for developers
===========================================================

Overview for Developers
-------------------------

Note that this file acts as both a sourced collection 
of bash functions ~/opticks/bin/oc.bash for development oc-vi
and as a deployed bash script when used via the installed 
\$(opticks-prefix)/bin/oc OR \$(opticks-prefix)/bin/opticks-config 
scripts which are actually symbolic links to the installed 
version of this file \$(opticks-prefix)/bin/oc.bash

Updating and Usage
---------------------

Update::
 
    oc-
    oc-vi

    cd ~/opticks/bin
    om-
    om--  

The last command installs oc.bash into the CMAKE_INSTALL_PREFIX/bin 
and plants symbolic links.

Developer Usage via bash functions
-------------------------------------

Use as bash functions::

   oc-
   oc-cflags NPY 
   oc-vi         # editing from the source tree 

Contrast with enduser usage via script::

   oc -cflags NPY
   oc --cflags NPY


pc functions
-----------------------------

Created bash name-pc functions for 
all externals which generate or fix the pc files.

Three that needed fixing were:assimp, gflw, glew with 
the "externals" moved from the prefix into the libdir and includedir,
in order for prefix to have the same meaning for both internals and externals.

A common prefix should eases relocatability when operating from 
distributions.


Overarching Thoughts on integated building of Opticks together with other frameworks like JUNO
------------------------------------------------------------------------------------------------

Opticks build is based on CMake and its find_package machinery 
that revolves around CMAKE_PREFIX_PATH envvar. 

Library symbol consistency makes it necessary for the Opticks build to 
use precisely the same installations of the common externals:: 

    boost 
    geant4  
    xerces-c

Integrated usage of Opticks (without CMake) with for example the CMT based
JUNO build is provided by using the opticks-config script which is built on 
top of pkg-config which revolves around the PKG_CONFIG_PATH envvar.  
In order to support this usage, the entire Opticks tree of packages, externals and
pre-requisites generates pkg-config pc files allowing any "node" of the Opticks  
tree of packages to be used without CMake.  
This is tested in examples/UseNameNoCMake/go.sh for around 32 such "Name"

Agreement in package finding between the pkg-config and CMake based 
systems is necessary. This means that CMAKE_PREFIX_PATH and PKG_CONFIG_PATH 
must be tied together to achieve the match.


TODO : generate the omitted geant4.pc and boost.pc in JUNOTOP
------------------------------------------------------------------

Annoyingly boost and geant4 do not provided pkg-config pc as part of their
installs : so have to fix this omission before can hope for pkg-config
and CMake resolvers to yield the same thing.

geant4.pc : bash generation using geant4-config
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For Geant4 just need a single geant4.pc similar to g4-pc-. 
The real solution would be to generate the .pc with CMake 
similar to what BCM/CMake does for the Opticks packages, because that has
the full information. But that is much more effort that some simple 
generation like g4-pc-. 

Checking github Geant4 shows that still no pc generation.

* https://github.com/Geant4/geant4/blob/master/cmake/Modules/G4ConfigurePkgConfigHelpers.cmake
* BUT realise that should use geant4-config rather than starting from scratch to generate the pc

boost.pc : adhoc bash generation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For Boost could make separate pc for the libs or do it all in one.
As Opticks is the only user and these pc are workarounds just do the simplest
single file. Because of the non-CMake boost build system have to just
use a workaround approach like boost-pc- 


TODO: test with UseBoost and UseGeant4
-----------------------------------------


TODO : operation with non-Opticks controlled boost and G4 
------------------------------------------------------------

Perhaps use the pc files as inputs in this case that carry the 
locations plucked by the Find ?


TODO : regularize imgui CMakeLists.txt its not using bcm_deploy forcing manual pc
-----------------------------------------------------------------------------------

TODO : pc Libs.private ?
--------------------------

NPY : had to make all libs PUBLIC for UseNPYNoCMake to work on Linux 


* https://stackoverflow.com/questions/45334645/which-cmake-property-should-hold-privately-linked-shared-libraries-for-imported
* https://stackoverflow.com/questions/32756195/recursive-list-of-link-libraries-in-cmake
* https://gitlab.kitware.com/cmake/cmake/issues/12435


TODO : get relocatable operation from a distributed installation to work
-------------------------------------------------------------------------- 

Cannot use "--define-prefix" for this as that demands a 
newer version of pkg-config that is commonly available.


pkg-config versions
---------------------

* https://www.freedesktop.org/wiki/Software/pkg-config/
* https://pkg-config.freedesktop.org/releases/

::

    [blyth@localhost UseSysRapNoCMake]$ pkg-config --version  ## from pkgconfig-0.27.1-4.el7.i686 
    0.27.1
    ## arghh : from 2012 : 0.27.1 doesnt have --define-prefix

    epsilon:cfg4 blyth$ pkg-config --version
    0.29.2


Requirements for pkg-config hookup
-------------------------------------

1. all packages (internal, external and preqs) need a .pc file to be 
   installed into lib/pkgconfig or externals/lib/pkgconfig : often 
   the simplest way to do that is via the bash functions that install
   the package 

2. CMake machinery needs to be informed for externals by addition 
   of the INTERFACE_PKG_CONFIG_NAME property to found targets, this 
   is most conveniently done in cmake/modules/FindName.cmake 

   The name corresponding to pkg-config pc file eg glm.pc, assimp.pc 

::

     39     set_target_properties(${_tgt} PROPERTIES
     40         INTERFACE_INCLUDE_DIRECTORIES "${GLM_INCLUDE_DIR}"
     41         INTERFACE_PKG_CONFIG_NAME "glm"
     42     )


   Despite pkg-config being usable without CMake the Opticks 
   build remains CMake based and most of the .pc files are generated
   by the BCMPkgConfig CMake machinery. It is because of this that 
   the CMake build needs to the INTERFACE_PKG_CONFIG_NAME for 
   inclusion into the generated pc files.

   After adding that property, need to rebuild and install 
   packages that use the dependency in order to re-generate the pc files.


Typical Usage
----------------

::

    opticks-
    oc-

    pkg=OpenMeshRap

    gcc -c $sdir/Use$pkg.cc $(oc-cflags $pkg)
    gcc Use$pkg.o -o Use$pkg $(oc-libs $pkg) 
    LD_LIBRARY_PATH=$(oc-libpath $pkg) ./Use$pkg


Hmm always using define-prefix means have to get rid of prefix var in below ?
------------------------------------------------------------------------------

* suppose use of macports xerces-c means have to add /opt/local/lib/pkgconfig 
  to PKG_CONFIG_PATH so --define-prefix then can operate correctly without changes
  to the pc

* hmm but its problematic from a cross platform point of view

::

    epsilon:UseOpticksXercesC blyth$ cat /opt/local/lib/pkgconfig/xerces-c.pc
    prefix=/opt/local
    exec_prefix=${prefix}
    libdir=${exec_prefix}/lib
    includedir=${prefix}/include

    Name: Xerces-C++
    Description: Validating XML parser library for C++
    Version: 3.2.1
    Libs: -L${libdir} -lxerces-c
    Libs.private: -lcurl
    Cflags: -I${includedir}


FIXED : define-prefix is scrubbing the CUDA include dir ?
-----------------------------------------------------------

define-prefix assumes the prefix can be obtained from the grandparent
dir of the /usr/local/opticks/xlib/pkgconfig/optickscuda.pc 
which yeilds /usr/local/opticks. This replaces the prefix variable 
if there is one defined in the pc file.

/usr/local/opticks/xlib/pkgconfig/optickscuda.pc::

    prefix=/usr/local/cuda
    includedir=${prefix}/include
    libdir=${prefix}/lib

    Name: CUDA
    Description: 
    Version: 9.1 
    Libs: -L${libdir} -lcudart -lcurand
    Cflags: -I${includedir}

The result is the wrong prefix.::

    epsilon:UseCUDARapNoCMake blyth$ oc-pkg-config optickscuda --cflags
    -I/usr/local/cuda/include

    epsilon:UseCUDARapNoCMake blyth$ oc-pkg-config optickscuda --cflags --define-prefix
    -I/usr/local/opticks/include

One solution is to exclude the prefix variable in pc files
of packages that are not going to be part of the distribution.  
This prevents --define-prefix from having any effect.

EOU
} 


#oc-extra(){ echo --define-prefix ; }  ## --define-prefix is a "recent" pkg-config addition, so better not to use it 
oc-extra(){ echo ; }
oc-lower(){ 
   local arg
   local larg
   for arg in "$@"
   do
      larg=$(echo $arg | tr "[A-Z]" "[a-z]")
      printf "%s " $larg
   done
}

oc-args-(){
   local arg
   for arg in "$@"
   do
      printf "%s\n" $arg
   done
}

oc-args(){ oc-args- $(oc-lower $*) ; }

oc-libdir-(){ oc-pkg-config $(oc-lower $*) --libs-only-L $(oc-extra) | tr -- "-L" " " ; }
oc-cflags-(){ oc-pkg-config $(oc-lower $*) --cflags $(oc-extra) ; }


oc-cflags(){ echo $(oc-cflags- $*) -std=c++11 ; }  ## seems the wrong place for c++11 ??
oc-libs(){   oc-pkg-config $(oc-lower $*) --libs   $(oc-extra) ; }
oc-libsl(){  oc-pkg-config $(oc-lower $*) --libs-only-L $(oc-extra) ; }
oc-deps(){   oc-pkg-config $(oc-lower $*) --print-requires  ; }
oc-dump(){   oc-pkg-config-dump $(oc-lower $*) ; }
oc-check(){  oc-pkg-config-check-dirs $(oc-lower $*) ; }
oc-find(){   oc-pkg-config-find $(oc-lower $*) ; }

oc-libdir(){  oc-libdir- $* | tr " " "\n" | sort | uniq ; }
oc-libpath(){ local dirs=$(oc-libdir $*) ; echo $dirs | tr " " ":" ; }

oc-cat(){    
   local pc=$(oc-find $*) 
   [ -n "$pc" -a -f "$pc" ] && cat $pc
}
oc-edit(){    
   local pc=$(oc-find $*) 
   [ -n "$pc" -a -f "$pc" ] && vi $pc
}

oc-setup()
{
   : TODO eliminate this transient  
   local iwd=$pwd
   cd $(opticks-prefix)
   # [ ! -x xlib ] && ln -s externals/lib xlib    ## now that cannot use --define-prefix not needed ?
   cd $iwd 

   ## the below is transient, they should be done on installing  
 
   optix-
   optix-pc
   cuda-
   cuda-pc
}



oc-prefix-notes(){ cat << EON

opticks-prefix is only defined when sourced 
when run from a script like ./go.sh that becomes $0

When using these functions from oc or opticks-config plucked
off the PATH the prefix should be determined from the path 
to this script, otherwise rely on having opticks-prefix function.

EON
}

oc-prefix(){
   local arg=$0
   if [ "${arg:(-2)}" == "oc" -o "${arg:(-14)}" == "opticks-config" ]
   then
       echo $(dirname $(dirname $0)) 
   else
       opticks-prefix
   fi
}


# "private" interface
oc-pkg-config-path--(){ cat << EOP
$(oc-prefix)/lib/pkgconfig
$(oc-prefix)/lib64/pkgconfig
$(oc-prefix)/externals/lib/pkgconfig
/opt/local/lib/pkgconfig
EOP
}
oc-pkg-config-path-(){
   local dir
   $FUNCNAME- | while read dir ; do
      [ -d "$dir" ] && echo $dir
   done
}
oc-pkg-config-path(){ echo $(oc-pkg-config-path-) | tr " " ":" ; }


oc-grep-prefix(){ oc-grep ^prefix ; }
oc-grep()
{
   local iwd=$PWD 
   local dir
   oc-pkg-config-path- | while read dir ; do
       cd $dir
       pwd
       grep $* *.pc
   done  
   cd $iwd 
}

oc-ls()
{
   local iwd=$PWD 
   local dir
   oc-pkg-config-path- | while read dir ; do
       cd $dir
       pwd
       ls -alst *.pc
   done  
   cd $iwd 
}



oc-info(){
   local pkg=${1:-NPY}

   cat << EOI

oc-info $pkg
========================

   \$0                : $0
   oc-prefix          : $(oc-prefix)
   oc-pkg-config-path : $(oc-pkg-config-path)

   oc-find $pkg : $(oc-find $pkg) 
   oc-cat $pkg  : 

   $(oc-cat $pkg) 


EOI

}


oc-pkg-config(){ PKG_CONFIG_PATH=$(oc-pkg-config-path) pkg-config $* ; }
oc-pcfix(){      PKG_CONFIG_PATH=$(oc-pkg-config-path) pc.py $* --fix ; }


oc-pkg-config-find(){
   local pkg=${1:-NPY}
   local lpkg=$(echo $pkg | tr [A-Z] [a-z])

   local dir
   local pc
   oc-pkg-config-path- | while read dir ; do 
      pc=$dir/${lpkg}.pc
      if [ -f "$pc" ]; then
         echo $pc
      fi 
   done
}

oc-pkg-config-dump(){
   local pkg=${1:-NPY}
   local opt
   $FUNCNAME-opts- | while read opt ; do 
       cmd="oc-pkg-config $pkg $opt"  
       printf "\n\n# %s\n\n"  "$cmd"
       $cmd | tr " " "\n"
   done
   oc-info $pkg
}

oc-pkg-config-dump-opts-(){ cat << EOC
--print-requires
--cflags 
--cflags-only-I 
--libs 
EOC

cat << EOO > /dev/null
--print-requires --define-prefix
--cflags --define-prefix
--libs --define-prefix
--cflags-only-I --define-prefix
EOO

}

oc-pkg-config-check-dirs(){
   local pkg=${1:-NPY}
   local line 
   local dir
   local exists 
   oc-pkg-config $pkg --cflags-only-I --define-prefix | tr " " "\n" | while read line ; do 
     dir=${line:2} 
     [ -d "$dir" ] && exists="Y" || exists="N"  
     printf " %s : %s \n" $exists $dir 
   done 
}


oc-variables-(){ 
  # used from templated .pc generation functions such as imgui-pc
  cat << EOV

# $FUNCNAME
prefix=$(oc-prefix)
includedir=\${prefix}/externals/include
libdir=\${prefix}/externals/lib

EOV
}


oc-main(){
   if [ "$#" == "0" ]; then
       oc-help 
   else 
       local cmd=$1
       shift
       #printf "cmd:%s:\n" $cmd 
       case $cmd in 
         --cflags|-cflags|-f) oc-cflags $* ;; 
             --libs|-libs|-l) oc-libs $* ;; 
       --libpath|-libpath|-p) oc-libpath $* ;; 
             --dump|-dump|-d) oc-dump $* ;; 
             --find|-find|-n) oc-find $* ;; 
               --cat|-cat|-c) oc-cat  $* ;; 
             --info|-info|-i) oc-info  $* ;; 
             --help|-help|-h) oc-help $* ;; 
                           *) oc-dump $cmd $* ;;   ## assume unrecognized command is a pkg name 
       esac
   fi 
}


if [ ! "$0" == "-bash" -o "$0" == "bash" ]; then   ## when used as a script rather than being sourced 
   if [ "$(basename $0)" == "opticks-config" -o "$(basename $0)" == "oc"  ]; then
       oc-main $*
   fi
fi

